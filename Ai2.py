import random


from copy import deepcopy
from queue import PriorityQueue

SELECTION_SIZE = 300
LOW_FITNESS_INDIVIDUALS = 10  # should be less than SELECTION_SIZE
MUTATION_SIZE = 250  # should be less than SELECTION_SIZE
CROSSOVER_SIZE = 250  # should be less than SELECTION_SIZE
GENERATION = 5
DEPTH = 4


class Ai2:

    def __init__(self, player, game):
        """
         The version of AI PLAYER CLASS
         """
        self.player = player
        if player == 1:
            self.adv = 2
        else:
            self.adv = 1
        self.played_sequence = []
        self.ai_game = game
        self._cols = game.get_cols()
        self._rows = game.get_rows()

    def ai_play(self, game):
        """
        Genetic Algorithm
        """
        self.complete_sequence(game)
        print('Current game sequence  = ', self.played_sequence)

        population = self.generate_population(game)
        fit_population = self.population_fitness(population)

        for gen in range(GENERATION):
            print("Generation %d : " % (gen + 1))
            selection = self.selection(fit_population)
            print(" Best before genetics = ", min(selection))
            self.population_crossover(CROSSOVER_SIZE, selection)
            self.population_mutation(MUTATION_SIZE, selection)
            self.fitness_evaluation(selection)
            fit_population = self.actual_generation(selection)
            print(" Best after genetics = ", min(selection))
            print(" Generation size = ", len(selection))

        best_move = fit_population.get()
        best_move = best_move[1]
        print("Playing move : ", best_move[0])
        game.place(best_move[0] - 1)
        self.complete_sequence(game)
        print('New game sequence  = ', self.played_sequence)
        return best_move[0] - 1

    def get_played_move(self, game):
        """
        get the move of the opponent
        """
        move = None
        for x in range(self._cols):
            for y in range(self._rows):
                if self.ai_game.board_at(x, y) != game.board_at(x, y):
                    move = x
                    return move
        return move

    def complete_sequence(self, game):
        """
        refresh the copy of the current sequence played until now
        """
        move = self.get_played_move(game)
        self.ai_game.place(move)
        self.played_sequence.append(move + 1)

    def get_sequence(self, game_copy, chromosome, depth):
        turn_counter = 0
        while game_copy.get_win() is None and turn_counter < depth:
            move = random.randint(0, 6)
            while game_copy.place(move) is None:
                move = random.randint(0, 6)
            chromosome.append(move + 1)
            turn_counter += 1
        return chromosome

    def generate_population(self, game):
        """
        generates a population of individuals which are possible game sequence
        """
        population = []
        for x in range(7):  # playing the seven possible moves
            current_game = game.copy_state()
            if current_game.place(x) is not None:
                for i in range(200):  # generate several possible sequence playing this move
                    # generate the rest of the sequence
                    population.append(self.get_sequence(current_game.copy_state(), [x + 1], DEPTH))
        return population

    def population_fitness(self, population):
        """Evaluates the fitness of each individual of the population"""
        fit_pop = PriorityQueue()
        for individual in population:
            value = self.fitness2(individual)
            fit_pop.put([-value, individual])
        return fit_pop

    def population_crossover(self, number, population):
        """
        Append the population with new individuals generated by crossover
        :param number: the number of crossover that has to be done
        :param population: the population on which it has to be done
        """
        nbr_of_individuals = len(population) - 1
        for i in range(number):
            individual1 = random.randint(0, nbr_of_individuals)
            individual2 = random.randint(0, nbr_of_individuals)
            while individual1 == individual2:
                individual2 = random.randint(0, nbr_of_individuals)
            new_individual1, new_individual2 = self.crossover(population[individual1][1], population[individual2][1])
            if new_individual1 is not None:
                population.append(new_individual1)
            if new_individual2 is not None:
                population.append(new_individual2)

    def population_mutation(self, number, population):
        """
        Append the population with new individuals generated by mutation
        :param number: the number of mutation that has to be done
        :param population: the population on which it has to be done
        """
        for i in range(number):
            individual = random.randint(0, SELECTION_SIZE - 1)
            new_individual = self.mutation(population[individual][1])
            population.append(new_individual)

    def fitness_evaluation(self, population):
        """
        Evaluates the fitness of individuals of the population which have not any fitness value
        :param population: the concern population
        """
        for i in range(SELECTION_SIZE, len(population)):
            value = self.fitness2(population[i])
            population[i] = [-value, population[i]]

    def actual_generation(self, population):
        """
        Sorting all individual by there fitness value
        :param population: the population to sort
        :return: sorted population
        """
        generation = PriorityQueue()
        for elem in population:
            generation.put(elem)
        return generation

    def selection(self, population):
        """
        Selecting SELECTION_SIZE individuals from the population
        :return: the selection
        """
        selection = []
        for i in range(SELECTION_SIZE):
            if i < SELECTION_SIZE - LOW_FITNESS_INDIVIDUALS:
                selection.append(population.get())
            else:
                selection.append(population.queue[-1])
        return selection

    def mutation(self, chromosome):
        """
        this function exchange two positions of a chromosome (individual)
        :param chromosome:
        :return: mutated chromosome
        """
        mutated_chromosome = deepcopy(chromosome)
        maxpos = len(mutated_chromosome) - 1
        pos1 = random.randint(0, maxpos)
        pos2 = random.randint(0, maxpos)
        while pos2 == pos1 and maxpos > 0:
            pos2 = random.randint(0, maxpos)
        mutated_chromosome[0], mutated_chromosome[pos2] = mutated_chromosome[pos2], mutated_chromosome[0]
        return mutated_chromosome

    def crossover(self, chromosome1, chromosome2):
        """
        this function cut the chromosome in two and exchange the second part with the second part of the other chromosom
        :param chromosome1:
        :param chromosome2:
        :return: two other chromosomes
        """
        total_length = len(chromosome1)
        if total_length > len(chromosome2):
            total_length = len(chromosome2)
        cross_pos = total_length // 2
        child1 = []
        child2 = []
        for i in range(total_length):
            if i < cross_pos:
                child1.append(chromosome1[i])
                child2.append(chromosome2[i])
            else:
                child1.append(chromosome2[i])
                child2.append(chromosome1[i])
        if not self.valid_child(child1):
            child1 = None
        if not self.valid_child(child2):
            child2 = None
        return child1, child2

    def valid_child(self, chromosome):
        """
        check if a chromosome has not exceed the number of possible move in a column
        :param chromosome: to check
        :return: the result
        """
        counter = [0 for x in range(7)]
        for elem in self.played_sequence:
            counter[elem - 1] = counter[elem - 1] + 1
        for elem in chromosome:
            counter[elem - 1] = counter[elem - 1] + 1
        for elem in counter:
            if elem > 6:
                return False
        return True

    def fitness2(self, chromosome):
        """
        used fitness function
        """
        value = 0
        val = 0
        game = self.ai_game.copy_state()
        for move in chromosome:
            game.place(move - 1)
            # test = self.prov(game)
            val += self.prov(game)
            """if test > val:
                val = test"""
        return val

    def prov(self, game):
        value = 0
        for i in range(7):
            for j in range(6):
                if i < 3:  # top
                    # print("yop 1")
                    value += self.aligned(game.get_board(), i, j, 1, 0)  # to the top
                    if j < 2:  # right
                        # print("yop 2")
                        value += self.aligned(game.get_board(), i, j, 1, 1)
                if j < 2:  # right
                    # print("yop 3")
                    value += self.aligned(game.get_board(), i, j, 0, 1)
                    if i > 2:  # left
                        # print("yop 4")
                        value += self.aligned(game.get_board(), i, j, -1, 1)
        # print("Value : ", value)
        return value

    def aligned(self, board, coord_x, coord_y, dir_x, dir_y):
        x, y = coord_x, coord_y
        nbr_clr, nbr_empty, i = 0, 0, 0
        color = 0
        value = 0
        while i < 4:
            # print(x,y)
            if color == 0:
                color = board[x][y]
            if board[x][y] == 0:
                nbr_empty += 1
            elif board[x][y] == color:
                nbr_clr += 1
            else:
                value -= 1
                break
            x += dir_x
            y += dir_y
            i += 1
        if nbr_clr + nbr_empty == 4:
            if nbr_clr == 2:
                value = 10
            elif nbr_clr == 3:
                value = 50
            elif nbr_clr == 4:
                value = 1000
        if color == self.adv:
            value *= -100
        return value

    def fitness(self, chromosome):
        """
        not used fitness function. see fitness2
        """
        value = 0
        game = self.ai_game.copy_state()
        for move in chromosome:
            game.place(move - 1)
            if game.get_turn() != self.player:  # Ai turn was played
                value += self.move_impact(game, move - 1)
            else:
                value -= self.move_impact(game, move - 1)  # opponent turn was played

        if game.get_win() == self.player:
            value += 1000
        return value

    def move_impact(self, game, move):
        """
        not used
        """
        x = move
        board = game.get_board()
        y = 0
        while game.board_at(x, y) != 0 and y < self._rows - 1:
            y += 1
        # checking the position (x, y)
        value = 0
        gain, wining_pos = self.vertical_gain(board, x, y)
        value += gain
        if wining_pos is not None:
            pass

        value += self.horizontal_gain(board, x, y)
        return value

    def vertical_gain(self, board, x, y):
        """
        not used
        """
        player = board[x][y]
        gain = 0
        min_row = max(y - 3, 0)
        max_row = min(y + 3, self._rows - 1)
        aligned_coins = 0
        wining_pos = None
        for r in range(y, min_row - 1, -1):
            if board[x][r] == player:
                gain += 1
                aligned_coins += 1
            else:
                break  # there are "aligned_coins" coins all ready align
        if 4 - aligned_coins <= max_row - y:  # it possible to align 4 coins in this column
            gain += 2
        if aligned_coins == 3:
            wining_pos = (x, y + 1)
        return gain, wining_pos

    def horizontal_gain(self, board, x, y):
        """
        not used
        """
        player = board[x][y]
        min_col = max(x - 3, 0)
        max_col = min(x + 3, self._cols - 1)
        gain = 0
        aligned_coins = 0
        gap = 0
        winning_pos = []
        for c in range(x, max_col + 1):
            if board[c][y] == player:
                gain += 2
                aligned_coins += 1
            elif board[c][y] == 0:
                gap += 1
                if gap > 1:
                    break
                winning_pos.append(c)
                gain += 1

            else:
                break
        for c in range(x - 1, min_col - 1, -1):
            if board[c][y] == player:
                gain += 2
                aligned_coins += 1
            elif board[c][y] == 0:
                gain += 1
                if board[c + 1][y] == player:
                    winning_pos.append(c)
            else:
                break
        if aligned_coins != 3:
            winning_pos = None
        return gain, winning_pos
